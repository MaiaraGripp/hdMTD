<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/combine/npm/katex@0.16.22/dist/katex.min.js,npm/katex@0.16.22/dist/contrib/auto-render.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/render-katex.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<pre><code class="language-r">####################################################
### R code to reproduce the submitted manuscript
###
### &quot;hdMTD:
###  An R Package for High-Dimensional Mixture Transition
###  Distribution Models&quot;
###
### Authors: Maiara Gripp, Guilherme Ost, Giulio Iacobelli, Daniel Y. Takahashi
### Date: July 2025
####################################################

# Required packages:
# install.packages(c(&quot;hdMTD&quot;, &quot;dplyr&quot;, &quot;ggplot2&quot;, &quot;lubridate&quot;, &quot;purrr&quot;, &quot;tidyr&quot;))

## Load packages
library(&quot;hdMTD&quot;)
library(&quot;dplyr&quot;)
</code></pre>
<pre><code>## Warning: pacote 'dplyr' foi compilado no R versão 4.4.3
</code></pre>
<pre><code>## 
## Anexando pacote: 'dplyr'
</code></pre>
<pre><code>## O seguinte objeto é mascarado por 'package:testthat':
## 
##     matches
</code></pre>
<pre><code>## Os seguintes objetos são mascarados por 'package:stats':
## 
##     filter, lag
</code></pre>
<pre><code>## Os seguintes objetos são mascarados por 'package:base':
## 
##     intersect, setdiff, setequal, union
</code></pre>
<pre><code class="language-r">library(&quot;ggplot2&quot;)
</code></pre>
<pre><code>## Warning: pacote 'ggplot2' foi compilado no R versão 4.4.3
</code></pre>
<pre><code class="language-r">library(&quot;lubridate&quot;)
</code></pre>
<pre><code>## Warning: pacote 'lubridate' foi compilado no R versão 4.4.3
</code></pre>
<pre><code>## 
## Anexando pacote: 'lubridate'
</code></pre>
<pre><code>## Os seguintes objetos são mascarados por 'package:base':
## 
##     date, intersect, setdiff, union
</code></pre>
<pre><code class="language-r">library(&quot;purrr&quot;)
</code></pre>
<pre><code>## Warning: pacote 'purrr' foi compilado no R versão 4.4.3
</code></pre>
<pre><code>## 
## Anexando pacote: 'purrr'
</code></pre>
<pre><code>## O seguinte objeto é mascarado por 'package:testthat':
## 
##     is_null
</code></pre>
<pre><code class="language-r">library(&quot;tidyr&quot;)
</code></pre>
<pre><code>## Warning: pacote 'tidyr' foi compilado no R versão 4.4.3
</code></pre>
<pre><code>## 
## Anexando pacote: 'tidyr'
</code></pre>
<pre><code>## O seguinte objeto é mascarado por 'package:testthat':
## 
##     matches
</code></pre>
<pre><code class="language-r">library(&quot;future&quot;)
</code></pre>
<pre><code>## Warning: pacote 'future' foi compilado no R versão 4.4.3
</code></pre>
<pre><code class="language-r">library(&quot;future.apply&quot;)
</code></pre>
<pre><code>## Warning: pacote 'future.apply' foi compilado no R versão 4.4.3
</code></pre>
<pre><code class="language-r">## Load precomputed outputs
precomputed &lt;- readRDS(file = &quot;hdMTD_outputs.rds&quot;)

# Set recompute_all = TRUE to override all precomputed results (not recommended)
recompute_all &lt;- FALSE

# All procedures that take longer than ~2 minutes were precomputed and stored in
# hdMTD_outputs.rds, simulated_data.rds and results_sequential_selection.rds.
# To recompute any of them, set the corresponding `recompute &lt;- TRUE` block to
# activate the code.
</code></pre>
<h2 id="sec:section-5-using-hdmtd">Section 5: Using hdMTD</h2>
<h3 id="sec:5-1-data-generation">5.1 Data generation</h3>
<ol>
<li>Generate MTD model:</li>
</ol>
<p>Parameters: \(\Lambda = \{-30,-15,-1\}\), \(\mathcal{A} = \{0,1\}\),
\(\lambda_0= \{0.01\}\), \(\lambda_{-1} = 0.39\), \(\lambda_{-15} = \lambda_{-30} = 0.3\),
\(p_0(0)=p_0(1)=0.5\), and transition matrices \(p_j\), \(j\in\Lambda\), sampled uniformly.</p>
<pre><code class="language-r">set.seed(11)
Lambda &lt;- c(1, 15, 30)
A &lt;- c(0, 1)
lam0 &lt;- 0.01
lamj &lt;- c(0.39, 0.3, 0.3)
p0 &lt;- c(0.5, 0.5)
MTD &lt;- MTDmodel(Lambda = Lambda, A = A, lam0 = lam0, lamj = lamj, p0 = p0)
summary(MTD)
</code></pre>
<pre><code>## Mixture Transition Distribution (MTD) model 
## 
## Call:
## MTDmodel(Lambda = Lambda, A = A, lam0 = lam0, lamj = lamj, p0 = p0)
## 
## Relevant lags: -1, -15, -30
## State space: 0, 1
## 
## lambdas (weights):
##   lam0  lam-1 lam-15 lam-30 
##   0.01   0.39   0.30   0.30 
## 
## Independent distribution p0:
## p0(0) p0(1) 
##   0.5   0.5 
## 
## Transition matrices pj (one per lag):
##  
##  pj for lag j = -1:
##            0         1
## 0 0.35190318 0.6480968
## 1 0.03558321 0.9644168
##  
##  pj for lag j = -15:
##           0         1
## 0 0.4278830 0.5721170
## 1 0.7670555 0.2329445
##  
##  pj for lag j = -30:
##           0         1
## 0 0.8341439 0.1658561
## 1 0.2184814 0.7815186
## 
## Transition matrix P: 8 x 2
## - Preview of first rows of P:
##             0         1
## 000 0.5208503 0.4791497
## 001 0.3974855 0.6025145
## 010 0.6226020 0.3773980
## 011 0.4992372 0.5007628
## 100 0.3361516 0.6638484
## 101 0.2127868 0.7872132
## 
## Reading guide for P:
## Rows list past contexts from oldest to newest, matching lags (-30, -15, -1).
</code></pre>
<ol start="2">
<li>Sample from the invariant distribution</li>
</ol>
<pre><code class="language-r">X &lt;- perfectSample(MTD, N = 1000)
</code></pre>
<h3 id="sec:5-2-estimation">5.2 Estimation</h3>
<ol start="3">
<li>Estimate relevant lags using FS method</li>
</ol>
<pre><code class="language-r">hdMTD_FS(X, d = 40, l = 4)
</code></pre>
<pre><code>## [1] 30 15  1 27
</code></pre>
<pre><code class="language-r">FS &lt;- hdMTD(X, d = 40, method = &quot;FS&quot;, l = 4)
S(FS); summary(FS)
</code></pre>
<pre><code>## [1] 30 15  1 27
</code></pre>
<pre><code>## hdMTD lag selection
## 
## Call:
## hdMTD(X = X, d = 40, method = &quot;FS&quot;, l = 4)
## 
## Method: FS
## Order upper bound (d): 40
## Selected S set: 30, 15, 1, 27
## 
## Relevant lag set estimated by FS method : -30, -15, -1, -27
</code></pre>
<ol start="4">
<li>Estimate relevant lags using BIC method</li>
</ol>
<pre><code class="language-r">recompute &lt;-  FALSE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
</code></pre>
<pre><code class="language-r">if (recompute) {
  hdMTD_BIC(X, d = 40, minl = 4, maxl = 4) #takes ~30min (on i7-1255U, 10 cores).
} else {
  precomputed$BIC_d40_l4
}
</code></pre>
<pre><code>## [1]  1 15 17 30
</code></pre>
<p>Custom subset S</p>
<pre><code class="language-r">hdMTD_BIC(X, d = 40,
          S = c(1, 5, 10, 15, 17, 20, 27, 30, 35, 40),
          minl = 4, maxl = 4)
</code></pre>
<pre><code>## [1]  1 15 17 30
</code></pre>
<p>Varying number of lags to be selected</p>
<pre><code class="language-r">hdMTD_BIC(X, d = 40,
          S = c(1, 5, 10, 15, 17, 20, 27, 30, 35, 40),
          minl = 1, maxl = 4)
</code></pre>
<pre><code>## [1] 30
</code></pre>
<p>With BIC values by number of lags</p>
<pre><code class="language-r">hdMTD_BIC(X, d = 40,
          S = c(1, 5, 10, 15, 17, 20, 27, 30, 35, 40),
          minl = 1, maxl = 4,
          byl = TRUE, BICvalue = TRUE)
</code></pre>
<pre><code>##           30        15,30      1,15,30   1,15,17,30 smallest: 30 
##     644.4959     648.0111     649.4950     650.2869     644.4959
</code></pre>
<p>Setting \(\xi=0.4\)</p>
<pre><code class="language-r">hdMTD_BIC(X, d = 40,
          S = c(1, 5, 10, 15, 17, 20, 27, 30, 35, 40),
          minl = 1, maxl = 4,
          byl = TRUE, BICvalue = TRUE,
          xi = 0.4)
</code></pre>
<pre><code>##                   30                15,30              1,15,30           1,15,17,30 smallest: 1,15,17,30 
##             641.7328             643.1757             642.5873             641.3069             641.3069
</code></pre>
<p>All matrices \(p_j\) are equal and \(\lambda_0=0\)</p>
<pre><code class="language-r">hdMTD_BIC(X, d = 40,
          S = c(1, 5, 10, 15, 17, 20, 27, 30, 35, 40),
          minl = 1, maxl = 4,
          byl = TRUE, BICvalue = TRUE,
          single_matrix = TRUE, indep_part = FALSE)
</code></pre>
<pre><code>##                   30                15,30              1,15,30           1,15,17,30 smallest: 1,15,17,30 
##             637.5881             634.1956             628.7718             622.6559             622.6559
</code></pre>
<ol start="5">
<li>Estimate relevant lags using CUT method</li>
</ol>
<pre><code class="language-r">recompute &lt;-  TRUE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
</code></pre>
<pre><code class="language-r">if (recompute) {
  hdMTD_CUT(X, d = 40, S = c(1, 5, 10, 15, 17, 20, 27, 30, 35, 40)) #takes ~2.5min.
} else {
  precomputed$CUT_d40
}
</code></pre>
<pre><code>##  [1]  1  5 10 15 17 20 27 30 35 40
</code></pre>
<pre><code class="language-r">recompute &lt;-  TRUE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
</code></pre>
<p>Setting \(\alpha = 0.13\)</p>
<pre><code class="language-r">if (recompute) {
  hdMTD_CUT(X, d = 40, S = c(1, 5, 10, 15, 17, 20, 27, 30, 35, 40), alpha = 0.13) #takes ~2.5min.
} else {
  precomputed$CUT_d40_alpha
}
</code></pre>
<pre><code>## [1]  1  5 27 35
</code></pre>
<p>Custom subset S</p>
<pre><code class="language-r">hdMTD_CUT(X, d = 40, S = c(1, 5, 17, 27, 30, 35), alpha = 0.13)
</code></pre>
<pre><code>## [1]  1  5 17 30
</code></pre>
<ol start="6">
<li>Estimate relevant lags using FSC method</li>
</ol>
<pre><code class="language-r">hdMTD_FSC(X, d = 40, l = 4, alpha = 0.1)
</code></pre>
<pre><code>## [1] 24 30
</code></pre>
<p>Equivalent call: hdMTD(X, d = 40, method = “FSC”, l = 4, alpha = 0.1)</p>
<p>FS method with halved sample</p>
<pre><code class="language-r">hdMTD_FS(X[1:500], d = 40, l = 4)
</code></pre>
<pre><code>## [1] 11 30  7 24
</code></pre>
<ol start="7">
<li>Estimating transition probabilities</li>
</ol>
<pre><code class="language-r">head(empirical_probs(X, S = c(1, 15, 30)), 6)
</code></pre>
<pre><code>##   past_{ -30,-15,-1 } a p(a|past)
## 1                 000 0 0.5000000
## 2                 000 1 0.5000000
## 3                 001 0 0.3714286
## 4                 001 1 0.6285714
## 5                 010 0 0.6306306
## 6                 010 1 0.3693694
</code></pre>
<pre><code class="language-r">empirical_probs(X, S = c(1, 15, 30), matrixform = TRUE)
</code></pre>
<pre><code>##             0         1
## 000 0.5000000 0.5000000
## 001 0.3714286 0.6285714
## 010 0.6306306 0.3693694
## 011 0.5065789 0.4934211
## 100 0.3861386 0.6138614
## 101 0.1987952 0.8012048
## 110 0.3888889 0.6111111
## 111 0.3697917 0.6302083
</code></pre>
<ol start="8">
<li>Oscillations</li>
</ol>
<p>Computing from MTD</p>
<pre><code class="language-r">oscillation(MTD)
</code></pre>
<pre><code>##        -1       -15       -30 
## 0.1233648 0.1017517 0.1846987
</code></pre>
<p>Estimating from sample</p>
<pre><code class="language-r">oscillation(X, S = c(1, 15, 30))
</code></pre>
<pre><code>##        -1       -15       -30 
## 0.1076339 0.1166363 0.1675360
</code></pre>
<ol start="9">
<li>Estimating MTD parameters through the EM algorithm</li>
</ol>
<p>Initial parameters for EM method</p>
<pre><code class="language-r">init &lt;- list(
  'lambdas'= c(0.01, 0.33, 0.33, 0.33),
  'p0' = c(0.5, 0.5),
  'pj' = rep(list(matrix(c(0.5, 0.5, 0.5, 0.5), ncol = 2, nrow = 2)), 3)
)
</code></pre>
<p>Run EM</p>
<pre><code class="language-r">emMTD &lt;- MTDest(X, S = c(1, 15, 30), init = init, iter = TRUE)
summary(emMTD)
</code></pre>
<pre><code>## Summary of EM estimation for MTD model:
## 
## Call:
## MTDest(X = X, S = c(1, 15, 30), init = init, iter = TRUE)
## 
## Lags (-S): -1, -15, -30 
## State space (A): 0, 1 
## 
## lambdas (weights):
##        lam0       lam-1      lam-15      lam-30 
## 0.009353147 0.323151043 0.326490125 0.341005685 
## 
## Independent distribution p0:
##     p0(0)     p0(1) 
## 0.3911887 0.6088113 
## 
## Transition matrices pj (one per lag):
##  
##  pj for lag j = -1:
##           0         1
## 0 0.5982386 0.4017614
## 1 0.2641061 0.7358939
##  
##  pj for lag j = -15:
##           0         1
## 0 0.1909446 0.8090554
## 1 0.5495934 0.4504066
##  
##  pj for lag j = -30:
##           0         1
## 0 0.6978307 0.3021693
## 1 0.2113007 0.7886993
## 
## Log-likelihood: -623.879 
## 
## Iterations Report:
## Number of updates: 9 
## Last compared difference of logLik: 0.00700394
</code></pre>
<p>Stops after \(9\) iterations</p>
<pre><code class="language-r">emMTD &lt;- MTDest(X, S = c(1, 15, 30), M = NULL, nIter = 9, init = init, oscillations = TRUE)
summary(emMTD)
</code></pre>
<pre><code>## Summary of EM estimation for MTD model:
## 
## Call:
## MTDest(X = X, S = c(1, 15, 30), M = NULL, init = init, nIter = 9, 
##     oscillations = TRUE)
## 
## Lags (-S): -1, -15, -30 
## State space (A): 0, 1 
## 
## lambdas (weights):
##        lam0       lam-1      lam-15      lam-30 
## 0.009353147 0.323151043 0.326490125 0.341005685 
## 
## Independent distribution p0:
##     p0(0)     p0(1) 
## 0.3911887 0.6088113 
## 
## Transition matrices pj (one per lag):
##  
##  pj for lag j = -1:
##           0         1
## 0 0.5982386 0.4017614
## 1 0.2641061 0.7358939
##  
##  pj for lag j = -15:
##           0         1
## 0 0.1909446 0.8090554
## 1 0.5495934 0.4504066
##  
##  pj for lag j = -30:
##           0         1
## 0 0.6978307 0.3021693
## 1 0.2113007 0.7886993
## 
## Log-likelihood: -623.879 
## 
## Oscillations:
##        -1       -15       -30 
## 0.1079753 0.1170953 0.1659095
</code></pre>
<p>Coercing an MTDest object to an MTD</p>
<pre><code class="language-r">emMTD &lt;- MTDest(X, S = c(1, 15, 30), init = init)
MTD_hat &lt;- as.MTD(emMTD)
</code></pre>
<p>Return estimated transition matrix</p>
<pre><code class="language-r">transitP(MTD_hat)
</code></pre>
<pre><code>##             0         1
## 000 0.4972860 0.5027140
## 001 0.3893107 0.6106893
## 010 0.6143813 0.3856187
## 011 0.5064060 0.4935940
## 100 0.3313766 0.6686234
## 101 0.2234013 0.7765987
## 110 0.4484718 0.5515282
## 111 0.3404966 0.6595034
</code></pre>
<h3 id="sec:5-3-testing-hdmtd">5.3 Testing hdMTD</h3>
<ol>
<li>MTD model specification:</li>
</ol>
<pre><code class="language-r">set.seed(123)
Lambda &lt;- c(1, 5)
A &lt;- c(0, 1)
lam0 &lt;- 0.01
p0 &lt;- c(0.5, 0.5)
MTD &lt;- MTDmodel(Lambda, A, lam0, p0 = p0) # Generates an MTD model
</code></pre>
<ol start="2">
<li>Simulation settings and results</li>
</ol>
<p>Simulation parameters:</p>
<pre><code class="language-r">n &lt;- 100      # Number of replications
N &lt;- 10000    # Full sample size
m &lt;- c(1000, 1500, 2000, 2500, 3000, 5000, 10000) # Subsample sizes
d &lt;- 100      # Max order for FS and Oracle
dNaive &lt;- 5   # Max order for Naive
pairList &lt;- t(combn(d, 2)) # All possible pairs with digits from 1 to 100
npairs &lt;- nrow(pairList)
minP11_P12 &lt;- min(MTD$P[1, 1], MTD$P[1, 2])
</code></pre>
<pre><code class="language-r">recompute &lt;-  FALSE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)

if (recompute) {

  FSP &lt;- matrix(0, ncol = length(m), nrow = n)
  FS  &lt;- matrix(0, ncol = length(m), nrow = n)
  NaiveP &lt;- matrix(0, ncol = length(m), nrow = n)
  Naive  &lt;- matrix(0, ncol = length(m), nrow = n)
  OracleP &lt;- matrix(0, ncol = length(m), nrow = n)
  Oracle  &lt;- matrix(0, ncol = length(m), nrow = n)
  SFS     &lt;- matrix(0, ncol = length(m) * 2, nrow = n)
  ZOracle &lt;- matrix(0, ncol = length(m) * 2, nrow = n)

  X_list &lt;- vector(&quot;list&quot;, n)
  for (i in seq_len(n)) {
    X_list[[i]] &lt;- perfectSample(MTD, N = N)
  }

  # 2) Paralel per replication
  workers &lt;- max(1, parallel::detectCores() - 1)
  plan(multisession, workers = workers)
  on.exit(plan(sequential), add = TRUE)

  res_list &lt;- future_lapply(seq_len(n), function(i) {
    X &lt;- X_list[[i]]

    FS_i &lt;- FSP_i &lt;- Naive_i &lt;- NaiveP_i &lt;- Oracle_i &lt;- OracleP_i &lt;- numeric(length(m))
    SFS_row &lt;- ZOracle_row &lt;- integer(length(m) * 2)

    for (k in seq_along(m)) {
      Y &lt;- X[seq_len(m[k])]
      ct &lt;- countsTab(Y, d = d)

      # FS
      S &lt;- hdMTD_FS(Y, d = d, l = 2)
      SFS_row[(k * 2 - 1):(k * 2)] &lt;- S
      p_FS &lt;- freqTab(S = S, A = A, countsTab = ct)$qax_Sj[1]
      err_FS &lt;- abs(p_FS - MTD$P[1, 1])
      FS_i[k]  &lt;- err_FS
      FSP_i[k] &lt;- err_FS / minP11_P12

      # Naive
      ct_dNaive &lt;- countsTab(Y, dNaive)
      p_Naive &lt;- freqTab(S = seq_len(dNaive), A = A, countsTab = ct_dNaive)$qax_Sj[1]
      err_NV &lt;- abs(p_Naive - MTD$P[1, 1])
      Naive_i[k]  &lt;- err_NV
      NaiveP_i[k] &lt;- err_NV / minP11_P12

      # Oracle
      p_pairs &lt;- numeric(npairs)
      for (s in seq_len(npairs)) {
        p_pairs[s] &lt;- freqTab(S = pairList[s, ], A = A, countsTab = ct)$qax_Sj[1]
      }
      minpos &lt;- which.min(abs(p_pairs - MTD$P[1, 1]))
      ZOracle_row[(k * 2 - 1):(k * 2)] &lt;- pairList[minpos, ]
      p_Oracle &lt;- p_pairs[minpos]
      err_OR &lt;- abs(p_Oracle - MTD$P[1, 1])
      Oracle_i[k]  &lt;- err_OR
      OracleP_i[k] &lt;- err_OR / minP11_P12
    }

    list(FS=FS_i, FSP=FSP_i, Naive=Naive_i, NaiveP=NaiveP_i,
         Oracle=Oracle_i, OracleP=OracleP_i,
         SFS=SFS_row, ZOracle=ZOracle_row)
  })

  FS      &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;FS&quot;))
  FSP     &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;FSP&quot;))
  Naive   &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;Naive&quot;))
  NaiveP  &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;NaiveP&quot;))
  Oracle  &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;Oracle&quot;))
  OracleP &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;OracleP&quot;))
  SFS     &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;SFS&quot;))
  ZOracle &lt;- do.call(rbind, lapply(res_list, `[[`, &quot;ZOracle&quot;))

} else {
  #' Load precomputed results from `simulated_data.rds`
  simulated_data &lt;- readRDS(&quot;simulated_data.rds&quot;)
  FS &lt;- simulated_data$FS
  FSP &lt;- simulated_data$FSP
  Oracle &lt;- simulated_data$Oracle
  OracleP &lt;- simulated_data$OracleP
  Naive &lt;- simulated_data$Naive
  NaiveP &lt;- simulated_data$NaiveP
  SFS &lt;- simulated_data$SFS
  ZOracle &lt;- simulated_data$ZOracle
}
</code></pre>
<ol start="3">
<li>Generate Table 1</li>
</ol>
<pre><code class="language-r">means_table &lt;- rbind(
  round(apply(FS, 2, mean), 5),
  round(apply(Oracle, 2, mean), 5),
  round(apply(Naive, 2, mean), 5),
  round(apply(FSP, 2, mean), 5),
  round(apply(OracleP, 2, mean), 5),
  round(apply(NaiveP, 2, mean), 5)
)
rownames(means_table) &lt;- c(
  &quot;Delta_FS(m)&quot;,
  &quot;Delta_Oracle(m)&quot;,
  &quot;Delta_Naive,5(m)&quot;,
  &quot;std Delta_FS(m)&quot;,
  &quot;std Delta_Oracle(m)&quot;,
  &quot;std Delta_Naive,5(m)&quot;
)
colnames(means_table) &lt;- m
</code></pre>
<p>Table 1: Mean error of estimators</p>
<pre><code class="language-r">knitr::kable(means_table, caption = &quot;Mean error of estimators&quot;, format = &quot;markdown&quot;, booktabs = TRUE, escape = FALSE)
</code></pre>
<p>Table: Mean error of estimators</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right">1000</th>
<th align="right">1500</th>
<th align="right">2000</th>
<th align="right">2500</th>
<th align="right">3000</th>
<th align="right">5000</th>
<th align="right">10000</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Delta_FS(m)</td>
<td align="right">0.02847</td>
<td align="right">0.02026</td>
<td align="right">0.01752</td>
<td align="right">0.01561</td>
<td align="right">0.01442</td>
<td align="right">0.01010</td>
<td align="right">0.00681</td>
</tr>
<tr>
<td align="left">Delta_Oracle(m)</td>
<td align="right">0.00728</td>
<td align="right">0.00916</td>
<td align="right">0.01104</td>
<td align="right">0.01167</td>
<td align="right">0.01150</td>
<td align="right">0.00971</td>
<td align="right">0.00681</td>
</tr>
<tr>
<td align="left">Delta_Naive,5(m)</td>
<td align="right">0.06786</td>
<td align="right">0.05845</td>
<td align="right">0.05534</td>
<td align="right">0.04974</td>
<td align="right">0.04485</td>
<td align="right">0.03412</td>
<td align="right">0.02508</td>
</tr>
<tr>
<td align="left">std Delta_FS(m)</td>
<td align="right">0.06469</td>
<td align="right">0.04605</td>
<td align="right">0.03981</td>
<td align="right">0.03547</td>
<td align="right">0.03278</td>
<td align="right">0.02295</td>
<td align="right">0.01547</td>
</tr>
<tr>
<td align="left">std Delta_Oracle(m)</td>
<td align="right">0.01655</td>
<td align="right">0.02081</td>
<td align="right">0.02509</td>
<td align="right">0.02651</td>
<td align="right">0.02614</td>
<td align="right">0.02207</td>
<td align="right">0.01547</td>
</tr>
<tr>
<td align="left">std Delta_Naive,5(m)</td>
<td align="right">0.15420</td>
<td align="right">0.13281</td>
<td align="right">0.12577</td>
<td align="right">0.11303</td>
<td align="right">0.10193</td>
<td align="right">0.07753</td>
<td align="right">0.05700</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>Compute how often the FS output differs from Oracle by subsample size</li>
</ol>
<pre><code class="language-r">m_index &lt;- seq(1, length(m)*2, by = 2)
names(m_index) &lt;- as.character(m)
SFS_vs_ZOracle_diff &lt;- sapply(m_index, function(idx) {
  SFS_set &lt;- apply(SFS[, c(idx, idx + 1)], 1, function(x) paste(sort(x), collapse = &quot;-&quot;))
  ZOracle_set &lt;- apply(ZOracle[, c(idx, idx + 1)], 1, function(x) paste(sort(x), collapse = &quot;-&quot;))
  sum(SFS_set != ZOracle_set)
})
SFS_vs_ZOracle_diff
</code></pre>
<pre><code>##  1000  1500  2000  2500  3000  5000 10000 
##    73    52    35    26    19     5     0
</code></pre>
<ol start="5">
<li>Generate Figure 1:</li>
</ol>
<p>Data arrangement</p>
<p>FS</p>
<pre><code class="language-r">tab &lt;- FS
FStab &lt;- rbind(apply(tab, 2, summary),'sd'=apply(tab, 2, sd))
FStab &lt;- rbind(FStab,'sdLo'=FStab[4,]-FStab[7,],'sdUp'=FStab[4,]+FStab[7,])
Fmean &lt;- FStab[4,]
FsdUp &lt;- FStab[9,]
FsdLo &lt;- FStab[8,]
Fq1 &lt;- FStab[2,]
Fq2 &lt;- FStab[3,]
Fq3 &lt;- FStab[5,]
</code></pre>
<p>NAIVE</p>
<pre><code class="language-r">tab &lt;- Naive
Naivetab &lt;- rbind(apply(tab, 2, summary),'sd'=apply(tab, 2, sd))
Naivetab &lt;- rbind(Naivetab,'sdLo'=Naivetab[4,]-Naivetab[7,],'sdUp'=Naivetab[4,]+Naivetab[7,])
Nmean &lt;- Naivetab[4,]
NsdUp &lt;- Naivetab[9,]
NsdLo &lt;- Naivetab[8,]
Nq1 &lt;- Naivetab[2,]
Nq2 &lt;- Naivetab[3,]
Nq3 &lt;- Naivetab[5,]
</code></pre>
<p>ORACLE</p>
<pre><code class="language-r">tab &lt;- Oracle
Oracletab &lt;- rbind(apply(tab, 2, summary),'sd'=apply(tab, 2, sd))
Oracletab &lt;- rbind(Oracletab,'sdLo'=Oracletab[4,]-Oracletab[7,],'sdUp'=Oracletab[4,]+Oracletab[7,])
Omean &lt;- Oracletab[4,]
OsdUp &lt;- Oracletab[9,]
OsdLo &lt;- Oracletab[8,]
Oq1 &lt;- Oracletab[2,]
Oq2 &lt;- Oracletab[3,]
Oq3 &lt;- Oracletab[5,]
</code></pre>
<h3 id="sec:plot-figure-1-estimators-mean-error-across-n-rep-100-replications">Plot Figure 1: Estimators mean error across \(N_{rep}=100\) replications.</h3>
<pre><code class="language-r">par(mfrow=c(1,2))

# --- Left panel: Mean error with standard deviation bands ---
 plot(m/100, Fmean, type = &quot;l&quot;, col = &quot;#377EB8&quot;,
      xlab = &quot;m (x100)&quot;, ylab = &quot;Mean error&quot;, ylim = c(0, 0.06),lwd=3,
      frame.plot = FALSE, xaxt=&quot;n&quot;, xlim = c(10,100))
 lines(m/100, Omean, type = &quot;l&quot;, col = &quot;#E41A1C&quot;,lwd=3)
 lines(m/100, Nmean, type = &quot;l&quot;, col = &quot;#4DAF4A&quot;,lwd=3)
 points(m/100, Fmean, col = &quot;#377EB8&quot;, pch=19,cex=0.7)
 points(m/100, Omean, col = &quot;#E41A1C&quot;, pch=19,cex=0.7)
 points(m/100, Nmean, col = &quot;#4DAF4A&quot;, pch=19,cex=0.7)
 lines(m/100, FsdUp, type = &quot;l&quot;, col = &quot;#377EB8&quot;, lty = 2)
 lines(m/100, FsdLo, type = &quot;l&quot;, col = &quot;#377EB8&quot;, lty = 2)
 lines(m/100, OsdUp, type = &quot;l&quot;, col = &quot;#E41A1C&quot;, lty = 2)
 lines(m/100, OsdLo, type = &quot;l&quot;, col = &quot;#E41A1C&quot;, lty = 2)
 lines(m/100, NsdUp, type = &quot;l&quot;, col = &quot;#4DAF4A&quot;, lty = 2)
 lines(m/100, NsdLo, type = &quot;l&quot;, col = &quot;#4DAF4A&quot;, lty = 2)
 axis(side = 1, at = m/100, labels = m/100)
 legend(&quot;topright&quot;,
        legend = c(expression(bar(Delta) ~ &quot;FS&quot;),
                   expression(bar(Delta) ~ &quot;FS&quot; %+-% &quot;sd&quot;),
                   expression(bar(Delta) ~ &quot;Oracle&quot;),
                   expression(bar(Delta) ~ &quot;Oracle&quot; %+-% &quot;sd&quot;),
                   expression(bar(Delta) ~ &quot;Naive&quot;),
                   expression(bar(Delta) ~ &quot;Naive&quot; %+-% &quot;sd&quot;)),
        col = c(&quot;#377EB8&quot;,&quot;#377EB8&quot;,&quot;#E41A1C&quot;,&quot;#E41A1C&quot;,&quot;#4DAF4A&quot;,&quot;#4DAF4A&quot;), lty = c(1,3,1,3,1,3), bty = &quot;n&quot;)
 # --- Right panel: Median and quartiles ---
 plot(m/100, Fq2, type = &quot;l&quot;, col = &quot;#377EB8&quot;,
      xlab = &quot;m (x100)&quot;, ylab = &quot;Quartiles of mean error&quot;, ylim = c(0, 0.06),lwd=3,
      frame.plot = FALSE, xaxt=&quot;n&quot;, xlim = c(10,100), lty=1)
 lines(m/100, Oq2, type = &quot;l&quot;, col = &quot;#E41A1C&quot;,lwd=3, lty=1)
 lines(m/100, Nq2, type = &quot;l&quot;, col = &quot;#4DAF4A&quot;,lwd=3, lty=1)
 points(m/100, Fq2, col = &quot;#377EB8&quot;, pch=19,cex=0.7)
 points(m/100, Oq2, col = &quot;#E41A1C&quot;, pch=19,cex=0.7)
 points(m/100, Nq2, col = &quot;#4DAF4A&quot;, pch=19,cex=0.7)
 lines(m/100, Fq1, type = &quot;l&quot;, col = &quot;#377EB8&quot;, lty = 2)
 lines(m/100, Fq3, type = &quot;l&quot;, col = &quot;#377EB8&quot;, lty = 2)
 lines(m/100, Oq1, type = &quot;l&quot;, col = &quot;#E41A1C&quot;, lty = 2)
 lines(m/100, Oq3, type = &quot;l&quot;, col = &quot;#E41A1C&quot;, lty = 2)
 lines(m/100, Nq1, type = &quot;l&quot;, col = &quot;#4DAF4A&quot;, lty = 2)
 lines(m/100, Nq3, type = &quot;l&quot;, col = &quot;#4DAF4A&quot;, lty = 2)
 axis(side = 1, at = m/100, labels = m/100)
 legend(&quot;topright&quot;,
        legend = c(expression(&quot;Med  &quot; ~ bar(Delta) ~ &quot;FS&quot;),
                   expression(&quot;q1,q3&quot; ~ bar(Delta) ~ &quot;FS&quot;),
                   expression(&quot;Med  &quot; ~ bar(Delta) ~ &quot;Oracle&quot;),
                   expression(&quot;q1,q3&quot; ~ bar(Delta) ~ &quot;Oracle&quot;),
                   expression(&quot;Med  &quot; ~ bar(Delta) ~ &quot;Naive&quot;),
                   expression(&quot;q1,q3&quot; ~ bar(Delta) ~ &quot;Naive&quot;)),
        col = c(&quot;#377EB8&quot;,&quot;#377EB8&quot;,&quot;#E41A1C&quot;,&quot;#E41A1C&quot;,&quot;#4DAF4A&quot;,&quot;#4DAF4A&quot;), lty = c(1,3,1,3,1,3), bty = &quot;n&quot;)
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk fig1-plot" /></p>
<h3 id="sec:5-4-analysis-of-real-world-data">5.4 Analysis of Real-World Data</h3>
<pre><code class="language-r">data(&quot;tempdata&quot;)
</code></pre>
<ol>
<li>Treat NA data:</li>
</ol>
<p>Removing days before “2010-08-05”</p>
<pre><code class="language-r">tempdata &lt;- hdMTD::tempdata %&gt;% filter(DATE &gt;= &quot;2010-08-05&quot;)
</code></pre>
<p>Identify remaining \(155\) NA positions</p>
<pre><code class="language-r">posNA &lt;- which(is.na(tempdata$MAXTEMP))
</code></pre>
<p>Fill short sequences of NAs ( \(≤6\) NAs) using nearest neighbors mean</p>
<pre><code class="language-r">for (i in posNA) {
  if(!is.na(tempdata$MAXTEMP[i - 1]) &amp;&amp; !all(is.na(tempdata$MAXTEMP[(i + 1):(i + 6)]))) {
    aux &lt;- which(!is.na(tempdata$MAXTEMP[(i + 1):(i + 6)]))[1]
    tempdata$MAXTEMP[i] &lt;- mean(tempdata$MAXTEMP[i - 1],tempdata$MAXTEMP[i + aux])
  }
}
</code></pre>
<p>Identify remaining \(88\) NA positions</p>
<pre><code class="language-r">posNA &lt;- which(is.na(tempdata$MAXTEMP))
</code></pre>
<p>Fill remaining NA with the mean of the previous hour temperature, next hour
temperature, and same hour of previous day temperature.</p>
<pre><code class="language-r">for (i in posNA) {
  tempdata$MAXTEMP[i] &lt;- mean(c(tempdata$MAXTEMP[i - 1], tempdata$MAXTEMP[i + 1],
                                tempdata$MAXTEMP[i - 24]),na.rm = TRUE)
}
</code></pre>
<ol start="2">
<li>Compute mean daily maximum temperatures:</li>
</ol>
<pre><code class="language-r">temp &lt;- tempdata %&gt;%
  group_by(DATE) %&gt;%
  summarize(MAXTEMP = mean(MAXTEMP), .groups = 'drop')
head(temp, 4)
</code></pre>
<pre><code>## # A tibble: 4 × 2
##   DATE       MAXTEMP
##   &lt;date&gt;       &lt;dbl&gt;
## 1 2010-08-05    20.7
## 2 2010-08-06    20.5
## 3 2010-08-07    21.8
## 4 2010-08-08    22.3
</code></pre>
<h3 id="sec:plot-figure-2-time-series-with-quarterly-mean-of-daily-maximum-temperatures">Plot Figure 2: Time series with quarterly mean of daily maximum temperatures</h3>
<pre><code class="language-r">TRIM_DATA &lt;- temp %&gt;%
  mutate(
    Y_TRIMESTER = paste0(year(DATE), &quot;-T&quot;, quarter(DATE))
  ) %&gt;%
  group_by(Y_TRIMESTER) %&gt;%
  summarise(
    MEAN_TEMP = mean(MAXTEMP),
    DATA_REF = min(DATE)
  ) %&gt;%
  ungroup() %&gt;%
  arrange(DATA_REF)
TRIM_DATA &lt;- TRIM_DATA[-c(1, nrow(TRIM_DATA)),]

ggplot(TRIM_DATA, aes(x = DATA_REF, y = MEAN_TEMP)) +
  geom_line(color = &quot;steelblue&quot;, linewidth = 0.5) +
  geom_point(color = &quot;steelblue&quot;, size = 1.2) +
  scale_x_date(
    date_breaks = &quot;1 year&quot;,
    date_labels = &quot;%Y&quot;,
    minor_breaks = NULL
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    panel.grid.major = element_line(color = &quot;gray90&quot;),
    axis.title.x = element_text(size = 15),
    axis.title.y = element_text(size = 15),
    plot.title = element_text(hjust = 0.5, size = 17, face = &quot;bold&quot;)
  ) +
  labs(
    title = &quot;Quarterly mean of daily maximum temperatures across the years&quot;,
    x = &quot;Year&quot;,
    y = &quot;Mean Temperature (°C)&quot;
  )
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk temp-plot" /></p>
<ol start="3">
<li>Create categories of temperature:</li>
</ol>
<pre><code class="language-r">xn &lt;- max(temp$MAXTEMP)
x1 &lt;- min(temp$MAXTEMP)
maxAmp &lt;- xn - x1
temp$MAXTEMP1  &lt;- ifelse(temp$MAXTEMP &lt; x1 + maxAmp/2, 1, 2)
head(temp, 4)
</code></pre>
<pre><code>## # A tibble: 4 × 3
##   DATE       MAXTEMP MAXTEMP1
##   &lt;date&gt;       &lt;dbl&gt;    &lt;dbl&gt;
## 1 2010-08-05    20.7        1
## 2 2010-08-06    20.5        1
## 3 2010-08-07    21.8        2
## 4 2010-08-08    22.3        2
</code></pre>
<pre><code class="language-r">prop.table(table(temp$MAXTEMP1)) # frequency of thermal regimes
</code></pre>
<pre><code>## 
##         1         2 
## 0.2606497 0.7393503
</code></pre>
<ol start="4">
<li>Run FS for temp:</li>
</ol>
<pre><code class="language-r">Temp12 &lt;- rev(temp$MAXTEMP1)
</code></pre>
<p>hdMTD functions assume the sample is sorted from the latest observations to
oldest.</p>
<pre><code class="language-r">recompute &lt;- TRUE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
</code></pre>
<pre><code class="language-r">if (recompute) {
  hdMTD_FS(Temp12, d = 400, l = 3) #takes ~7min.
} else {
  precomputed$FS_Temp12_d400
}
</code></pre>
<pre><code>## [1]   1 364   6
</code></pre>
<p>Note: The next code line is mentioned in the article but without a CodeChunk <br>
Reduce maximum order to improve estimation <br></p>
<pre><code class="language-r">recompute &lt;-  FALSE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
</code></pre>
<pre><code class="language-r">if (recompute) {
  hdMTD_FS(Temp12, d = 364, l = 3) #takes ~6min.
} else {
  precomputed$FS_Temp12_d364
}
</code></pre>
<pre><code>## [1]   1 364   6
</code></pre>
<ol start="5">
<li>Split sample in Train and Test data:</li>
</ol>
<pre><code class="language-r">ndays &lt;- nrow(temp %&gt;%
                filter(DATE &gt;= &quot;2023-09-01&quot;)) # 366 days in the latest year of the sample
Temp12_Train &lt;- Temp12[-seq_len(ndays)] # Training data with 4775 days
Temp12_Test &lt;- Temp12[seq_len(ndays)] # Test data
</code></pre>
<ol start="6">
<li>Rerun FS for Train data:</li>
</ol>
<pre><code class="language-r">recompute &lt;-  TRUE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
</code></pre>
<pre><code class="language-r">if (recompute) {
  hdMTD_FS(Temp12_Train, d = 364, l = 3) #takes ~5min.
} else {
  precomputed$FS_Temp12Train
}
</code></pre>
<pre><code>## [1]   1 364   6
</code></pre>
<ol start="7">
<li>Trim out irrelevant lags:</li>
</ol>
<p>With CUT method</p>
<pre><code class="language-r">hdMTD_CUT(Temp12_Train, d = 364, S = c(1, 364, 6))
</code></pre>
<pre><code>## [1]   1   6 364
</code></pre>
<p>With BIC method</p>
<pre><code class="language-r">hdMTD_BIC(Temp12_Train, d = 364, S = c(1, 364, 6), minl = 1, maxl = 3,
          byl = TRUE, BICvalue = TRUE )
</code></pre>
<pre><code>##                 1             1,364           1,6,364 smallest: 1,6,364 
##          1720.801          1690.543          1674.080          1674.080
</code></pre>
<ol start="8">
<li>Lag selection with FSC method:</li>
</ol>
<pre><code class="language-r">recompute &lt;-  TRUE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
</code></pre>
<pre><code class="language-r">if (recompute) {
  hdMTD_FSC(Temp12_Train, d = 364, l = 3) #takes ~3min.
} else {
  precomputed$FSC_Temp12Train
}
</code></pre>
<pre><code>## [1]   1   6 364
</code></pre>
<ol start="9">
<li>Estimated transition matrix for FS method output:</li>
</ol>
<pre><code class="language-r">P_FS &lt;- empirical_probs(Temp12_Train, S = c(1, 6, 364), matrixform = T)
P_FS
</code></pre>
<pre><code>##              1         2
## 111 0.86626140 0.1337386
## 112 0.24736842 0.7526316
## 121 0.77157360 0.2284264
## 122 0.13318777 0.8668122
## 211 0.78846154 0.2115385
## 212 0.10972569 0.8902743
## 221 0.57506361 0.4249364
## 222 0.07283555 0.9271645
</code></pre>
<h3 id="sec:classic-method-for-choosing-relevant-lag-set">Classic method for choosing relevant lag set:</h3>
<ol start="10">
<li>Compute models:</li>
</ol>
<pre><code class="language-r">ct &lt;- countsTab(Temp12_Train, d = 6) # Table with size 6 sequence counts
head(ct,4)
</code></pre>
<pre><code>## # A tibble: 4 × 8
##      x6    x5    x4    x3    x2    x1     a   Nxa
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;
## 1     1     1     1     1     1     1     1   342
## 2     1     1     1     1     1     1     2    62
## 3     1     1     1     1     1     2     1    18
## 4     1     1     1     1     1     2     2    62
</code></pre>
<p>MC1 (does not explicitly appear in the article)</p>
<pre><code class="language-r">ft &lt;- freqTab(S = 1, A = c(1, 2), countsTab = ct)
LL &lt;- sum(log(ft$qax_Sj) * ft$Nxa_Sj)
freeParam &lt;- 2 * 1
BICMC1 &lt;- -LL + 0.5 * log(length(Temp12_Train)) * freeParam
BICMC1
</code></pre>
<pre><code>## [1] 1869.162
</code></pre>
<p>Comparable BIC if the model is a Markov chain of order \(1\): \(1869.162\)</p>
<p>MC2 (does not explicitly appear in the article)</p>
<pre><code class="language-r">ft &lt;- freqTab(S = c(1, 2), A = c(1, 2), countsTab = ct)
LL &lt;- sum(log(ft$qax_Sj) * ft$Nxa_Sj)
freeParam &lt;- 2^2 * 1
BICMC2 &lt;- -LL + 0.5 * log(length(Temp12_Train)) * freeParam
BICMC2
</code></pre>
<pre><code>## [1] 1850.598
</code></pre>
<p>Comparable BIC if the model is a Markov chain of order \(2\): \(1850.598\)</p>
<p>MC3. Used as example in the article</p>
<pre><code class="language-r">ft &lt;- freqTab(S = c(1, 2, 3), A = c(1, 2), countsTab = ct)
head(ft, 4)
</code></pre>
<pre><code>## # A tibble: 4 × 7
##      x3    x2    x1     a Nxa_Sj Nx_Sj qax_Sj
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
## 1     1     1     1     1    587   726  0.809
## 2     1     1     1     2    139   726  0.191
## 3     1     1     2     1     38   206  0.184
## 4     1     1     2     2    168   206  0.816
</code></pre>
<pre><code class="language-r">LL &lt;- sum(log(ft$qax_Sj) * ft$Nxa_Sj)
freeParam &lt;- 2^3 * 1
BICMC3 &lt;- -LL + 0.5 * log(length(Temp12_Train)) * freeParam
BICMC3
</code></pre>
<pre><code>## [1] 1854.029
</code></pre>
<p>Comparable BIC if the model is a Markov chain of order \(3\): \(1854.029\)</p>
<p>MC4 (does not explicitly appear in the article)</p>
<pre><code class="language-r">ft &lt;- freqTab(S = c(1, 2, 3, 4), A = c(1, 2), countsTab = ct)
LL &lt;- sum(log(ft$qax_Sj) * ft$Nxa_Sj)
freeParam &lt;- 2^4 * 1
BICMC4 &lt;- -LL + 0.5 * log(length(Temp12_Train)) * freeParam
BICMC4
</code></pre>
<pre><code>## [1] 1877.888
</code></pre>
<p>Comparable BIC if the model is a Markov chain of order \(4\): \(1877.888\)</p>
<p>MC5 (does not explicitly appear in the article)</p>
<pre><code class="language-r">ft &lt;- freqTab(S = c(1, 2, 3, 4, 5), A = c(1, 2), countsTab = ct)
pos &lt;- which(ft$Nxa_Sj &gt; 0)
LL &lt;- sum(log(ft$qax_Sj[pos]) * ft$Nxa_Sj[pos])
freeParam &lt;- 2^5 * 1
BICMC5 &lt;- -LL + 0.5 * log(length(Temp12_Train)) * freeParam
BICMC5
</code></pre>
<pre><code>## [1] 1925.962
</code></pre>
<p>Comparable BIC if the model is a Markov chain of order \(5\): \(1925.962\)</p>
<p>MC6 (does not explicitly appear in the article)</p>
<pre><code class="language-r">ft &lt;- freqTab(S = c(1, 2, 3, 4, 5, 6), A = c(1, 2), countsTab = ct)
pos &lt;- which(ft$Nxa_Sj &gt; 0)
LL &lt;- sum(log(ft$qax_Sj[pos]) * ft$Nxa_Sj[pos])
freeParam &lt;- 2^6 * 1
BICMC6 &lt;- -LL + 0.5 * log(length(Temp12_Train)) * freeParam
BICMC6
</code></pre>
<pre><code>## [1] 2031.679
</code></pre>
<p>Comparable BIC if the model is a Markov chain of order \(6\): \(2031.679\)</p>
<ol start="11">
<li>Comparing models:</li>
</ol>
<pre><code class="language-r">BIC_vals &lt;-  c(BICMC1, BICMC2, BICMC3, BICMC4, BICMC5, BICMC6)
model_names &lt;- paste0(&quot;MC&quot;, 1:6)
minBIC_idx &lt;- which.min(BIC_vals)
BIC_fmt &lt;- sprintf(&quot;%.3f&quot;, BIC_vals)
BIC_fmt[minBIC_idx] &lt;- paste0(&quot;**&quot;, BIC_fmt[minBIC_idx], &quot;**&quot;)
minBIC_idx
</code></pre>
<pre><code>## [1] 2
</code></pre>
<p>The classic method chooses order \(2\) (\(S=\{-2,-1\}\)).</p>
<p>Table 2: BIC values</p>
<pre><code class="language-r">bic_matrix &lt;- data.frame(matrix(BIC_fmt, nrow = 1))
colnames(bic_matrix) &lt;- model_names
rownames(bic_matrix) &lt;- &quot;BIC&quot;
</code></pre>
<pre><code class="language-r">knitr::kable(bic_matrix, caption = &quot;BIC values computed for classical Markov chain models of different orders.&quot;)
</code></pre>
<p>Table: BIC values computed for classical Markov chain models of different orders.</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">MC1</th>
<th align="left">MC2</th>
<th align="left">MC3</th>
<th align="left">MC4</th>
<th align="left">MC5</th>
<th align="left">MC6</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">BIC</td>
<td align="left">1869.162</td>
<td align="left"><strong>1850.598</strong></td>
<td align="left">1854.029</td>
<td align="left">1877.888</td>
<td align="left">1925.962</td>
<td align="left">2031.679</td>
</tr>
</tbody>
</table>
<p>Estimated matrix for \(S=\{-2,-1\}\)</p>
<pre><code class="language-r">P_MC2 &lt;- empirical_probs(Temp12_Train, S = c(1, 2), matrixform = TRUE)
P_MC2
</code></pre>
<pre><code>##             1         2
## 11 0.77813505 0.2218650
## 12 0.16326531 0.8367347
## 21 0.60233918 0.3976608
## 22 0.09064976 0.9093502
</code></pre>
<p>Independent model distribution:</p>
<pre><code class="language-r">P_Ind &lt;- prop.table(table(Temp12_Train))
P_Ind
</code></pre>
<pre><code>## Temp12_Train
##         1         2 
## 0.2672251 0.7327749
</code></pre>
<h3 id="sec:comparing-methods">Comparing methods</h3>
<ol start="12">
<li>Computing values for Table 3.</li>
</ol>
<pre><code class="language-r">Days1 &lt;- which(Temp12_Test == 1)
lenDays1 &lt;- length(Days1)
lenDays1 / ndays # frequency of low temperature days
</code></pre>
<pre><code>## [1] 0.1748634
</code></pre>
<pre><code class="language-r">Temp12_Test &lt;- c(Temp12_Test, Temp12_Train[seq_len(364)])
</code></pre>
<pre><code class="language-r">set.seed(1)
hitInd &lt;- numeric(1000)
hitMC2 &lt;- numeric(1000)
hitFS &lt;- numeric(1000)
T1Ind &lt;- numeric(1000)
T1MC2 &lt;- numeric(1000)
T1FS &lt;- numeric(1000)
F1Ind &lt;- numeric(1000)
F1MC2 &lt;- numeric(1000)
F1FS &lt;- numeric(1000)
pasts2 &lt;- rownames(P_MC2)
pastsFS &lt;- rownames(P_FS)
</code></pre>
<pre><code class="language-r">for (j in seq_len(1000)){
  u &lt;- runif(ndays)
  predInd &lt;- numeric(ndays)
  predMC2 &lt;- numeric(ndays)
  predFS &lt;- numeric(ndays)

  for (i in ndays:1) {
    predInd[i] &lt;- ifelse(u[i] &lt;= P_Ind[1], 1, 2)
    pastRow &lt;- which(pasts2 == paste0(rev(Temp12_Test[c(i+1, i+2)]), collapse = &quot;&quot;))
    predMC2[i] &lt;- ifelse(u[i] &lt;= P_MC2[pastRow, 1], 1, 2)
    pastRow &lt;- which(pastsFS == paste0(rev(Temp12_Test[c(i+1, i+6, i+364)]), collapse = &quot;&quot;))
    predFS[i] &lt;- ifelse(u[i] &lt;= P_FS[pastRow, 1], 1, 2)
  }

  hitInd[j] &lt;- sum(predInd == Temp12_Test[seq_len(ndays)])
  hitMC2[j] &lt;- sum(predMC2 == Temp12_Test[seq_len(ndays)])
  hitFS[j] &lt;- sum(predFS == Temp12_Test[seq_len(ndays)])
  T1Ind[j] &lt;- sum(predInd[Days1] == 1)
  T1MC2[j] &lt;- sum(predMC2[Days1] == 1)
  T1FS[j] &lt;- sum(predFS[Days1] == 1)
  F1Ind[j] &lt;- sum(predInd[-Days1] == 1)
  F1MC2[j] &lt;- sum(predMC2[-Days1] == 1)
  F1FS[j] &lt;- sum(predFS[-Days1] == 1)
}
</code></pre>
<h3 id="sec:accuracy">Accuracy</h3>
<pre><code class="language-r">AccInd &lt;- mean(hitInd)/ndays
AccMC2 &lt;- mean(hitMC2)/ndays
AccFS &lt;- mean(hitFS)/ndays
AccInd; AccMC2; AccFS
</code></pre>
<pre><code>## [1] 0.6509262
</code></pre>
<pre><code>## [1] 0.8236585
</code></pre>
<pre><code>## [1] 0.8349153
</code></pre>
<h3 id="sec:precision">Precision</h3>
<pre><code class="language-r">PrecInd &lt;- mean(T1Ind/(T1Ind + F1Ind))
PrecMC2 &lt;- mean(T1MC2/(T1MC2 + F1MC2))
PrecFS &lt;- mean(T1FS/(T1FS + F1FS))
PrecInd; PrecMC2; PrecFS
</code></pre>
<pre><code>## [1] 0.1745824
</code></pre>
<pre><code>## [1] 0.4981026
</code></pre>
<pre><code>## [1] 0.5249133
</code></pre>
<h3 id="sec:sensitivity-recall">Sensitivity (Recall)</h3>
<pre><code class="language-r">SensInd &lt;- mean(T1Ind)/lenDays1
SensMC2 &lt;- mean(T1MC2)/lenDays1
SensFS &lt;- mean(T1FS)/lenDays1
SensInd; SensMC2; SensFS
</code></pre>
<pre><code>## [1] 0.2671875
</code></pre>
<pre><code>## [1] 0.5870313
</code></pre>
<pre><code>## [1] 0.6294531
</code></pre>
<h3 id="sec:specificity">Specificity</h3>
<pre><code class="language-r">SpecInd &lt;- 1 - mean(F1Ind)/(ndays - lenDays1)
SpecMC2 &lt;- 1 - mean(F1MC2)/(ndays - lenDays1)
SpecFS &lt;- 1 - mean(F1FS)/(ndays - lenDays1)
SpecInd; SpecMC2; SpecFS
</code></pre>
<pre><code>## [1] 0.7322483
</code></pre>
<pre><code>## [1] 0.8738046
</code></pre>
<pre><code>## [1] 0.878457
</code></pre>
<h3 id="sec:f1-score">F1-Score</h3>
<pre><code class="language-r">F1ScoreInd &lt;- 2 * (PrecInd * SensInd) / (PrecInd + SensInd)
F1ScoreMC2 &lt;- 2 * (PrecMC2 * SensMC2) / (PrecMC2 + SensMC2)
F1ScoreFS &lt;- 2 * (PrecFS * SensFS) / (PrecFS + SensFS)
F1ScoreInd; F1ScoreMC2; F1ScoreFS
</code></pre>
<pre><code>## [1] 0.2111789
</code></pre>
<pre><code>## [1] 0.538923
</code></pre>
<pre><code>## [1] 0.5724496
</code></pre>
<p>Table 3: Model performance metrics</p>
<pre><code class="language-r">metric &lt;- c(&quot;Accuracy&quot;, &quot;Precision&quot;, &quot;Sensitivity (Recall)&quot;, &quot;Specificity&quot;, &quot;F1-Score&quot;)
formula &lt;- c(&quot;(TP+TN)/(TP+TN+FP+FN)&quot;,
             &quot;TP/(TP+FP)&quot;,
             &quot;TP/(TP+FN)&quot;,
             &quot;TN/(TN+FP)&quot;,
             &quot;2(PPV*Recall)/(PPV+Recall)&quot;)
performance_table &lt;- data.frame(
  Metric = metric,
  Formula = formula,
  indc = round(c(AccInd, PrecInd, SensInd, SpecInd, F1ScoreInd) * 100, 2),
  mc2c = round(c(AccMC2, PrecMC2, SensMC2, SpecMC2, F1ScoreMC2) * 100, 2),
  fsc = round(c(AccFS, PrecFS, SensFS, SpecFS, F1ScoreFS) * 100, 2),
  check.names = FALSE
)
names(performance_table) &lt;- c(&quot;Metric&quot;, &quot;Formula&quot;, &quot;Ind (\\%)&quot;, &quot;MC2 (\\%)&quot;, &quot;FS (\\%)&quot;)
</code></pre>
<pre><code class="language-r">knitr::kable(performance_table, align = &quot;l&quot;, caption = &quot;Model performance metrics.&quot;)
</code></pre>
<p>Table: Model performance metrics.</p>
<table>
<thead>
<tr>
<th align="left">Metric</th>
<th align="left">Formula</th>
<th align="left">Ind (%)</th>
<th align="left">MC2 (%)</th>
<th align="left">FS (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Accuracy</td>
<td align="left">(TP+TN)/(TP+TN+FP+FN)</td>
<td align="left">65.09</td>
<td align="left">82.37</td>
<td align="left">83.49</td>
</tr>
<tr>
<td align="left">Precision</td>
<td align="left">TP/(TP+FP)</td>
<td align="left">17.46</td>
<td align="left">49.81</td>
<td align="left">52.49</td>
</tr>
<tr>
<td align="left">Sensitivity (Recall)</td>
<td align="left">TP/(TP+FN)</td>
<td align="left">26.72</td>
<td align="left">58.70</td>
<td align="left">62.95</td>
</tr>
<tr>
<td align="left">Specificity</td>
<td align="left">TN/(TN+FP)</td>
<td align="left">73.22</td>
<td align="left">87.38</td>
<td align="left">87.85</td>
</tr>
<tr>
<td align="left">F1-Score</td>
<td align="left">2(PPV*Recall)/(PPV+Recall)</td>
<td align="left">21.12</td>
<td align="left">53.89</td>
<td align="left">57.24</td>
</tr>
</tbody>
</table>
<h3 id="sec:plot-figure-3-exploratory-analysis-of-accuracies">Plot Figure 3: Exploratory analysis of accuracies</h3>
<pre><code class="language-r">accuracy_data &lt;- data.frame(
  MC2 = hitMC2 / ndays,
  FS = hitFS / ndays
) %&gt;%
  pivot_longer(
    everything(),
    names_to = &quot;Model&quot;,
    values_to = &quot;Accuracy&quot;
  )

ggplot(accuracy_data, aes(x = Model, y = Accuracy, fill = Model)) +
  geom_boxplot() +
  labs(
    title = &quot;Accuracy distribution (1000 replications)&quot;,
    x = &quot;Model&quot;,
    y = &quot;Accuracy&quot;
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = &quot;Paired&quot;) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = &quot;bold&quot;),
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14)
  )
</code></pre>
<p><img src="data:image/png;base64,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EWkDEfkDETkBEWkDEfkDETkBEWkDEfkDETkBEWkDEflzeRFf0uHmsguwglTooAEtIifQItIGIvIHInICItIGIvIHInICItIGIvIHInICItIGIvIHInICItIGIvIHInICItIGIvIHInICItIGIvIHInICItJmZUQUHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAf1i3i+32533PbZo3Z7S30f3Wu327deNFGwRRBcP1kEB/WKeL6/pfzrxNvn+2r7dKuhYi2G4PrJIjioV8TRB0+VeLb1O3u0F4YnSsLDveZKtgCC6yeL4KBeEY2Do/tHejtqEc+ffEixZ5ZcP1kEB/WKeGJE1M2i5rDd3gttVz16YE18SYebyy5AUxAKuhQRjYCHbnxo+mlaCG4osggOWqhrPk23juf7EHFZCA7qn6xoB91kJRLx9C312Nnjp80VrxiC6yeL4KCFlm9s13zrhWkMT+nNVgTXTxbBQfMXtA87dkFb+xd9J4bg+skiOCgu8XFCcNBmRbzJi0bPTRHolagyGhbxz5ygV+30SlQZENEPvWqnV6LKgIh+6FU7vRJVBkT0Q6/a6ZWoMiCiH3rVTq9ElQER/dCrdnolqgyI6IdetdMrUWVARD/0qp1eiSoDIvqhV+30SlQZENEPvWqnV6LKgIh+6FU7vRJVBkT0Q6/a6ZWoMiCiH3rVTq9ElQER/dCrdnolqgyI6IdetdMrUWVARD/0qp1eiSoDIvqhV+30SlQZENEPvWqnV6LKgIh+6FU7vRJVBkT0Q6/a6ZWoMiCiH3rVTq9ElQER/dCrdnolqgyI6IdetdMrUWVARD/0qp1eiSoDIvqhV+30SlQZENEPvWqnV6LKwEeOXECj56YI9EpUGRDxAhC0OdA1+ykj4o84ARFpAxEbBCL6gYgNAhH9QMQGgYh+IGKDQEQ/ELFBIKIfiNggENEPRGwQiOgHIjYIRPQDERsEIvqBiA0CEf1AxAaBiH4gYoNARD8QsUEgoh+I2CAQ0Q9EbBCI6AciNghE9AMRGwQi+oGIDZKION4OWnW/GkQkCS0Rw7AfBDW7CBFJQk3EsHYXISJJCIpoVVw/qOnVICJJ6Ik4UBbuhJPu1eN6Xg0ikoSYiGq2ElgDB3U1iRCRJLREHG+v7db9ahCRJLREbILVEZEX1dXwpUmL2FMd86DwpPnlJVj2CV+Qy0RclaAzPky6Tp1BMDPFGKQ62/H2To6IPfP88fZGQRPpQOE3OssKds1KRCtgr6SI0Q61zVTqAyKWoyIRf3Bb6zZ++91yIk66tmXtQ8TyrKSIGz1t0ODqx1rEQXRppB8Ea59qEd3FkvyuuR/oPYabtV9xrhyIWI6qRBxoA3stO9fYsaO8nmrXBoESsa/+abnyRVS7KWfrX8OpHohYjqpEHF47CMe3d5WItntVPfJwU2vXW9sdb5tH1g8KiMgWiFiOqkScdHdUz3ysRLT+qa92xqGMtMNE9QhEbJLVFDHsb6ieOYxFVM71YxEDSwER9SW+oM5bHmoDIpajMhGH1756uBte0CKGBdcRldH2ELyAiOWoTMRJ9z01TJwdI/b1GNF5VWAdsaU7+LBf16039QERy1GZiGEv2Iiu0LlZs54sx7NmO2spsKCtpz36HzMgYjmqE1H7Zy/RzV9HVB11oQVtNfeGiFWwgiKWJL2grXRVcx50zRUAERclc/fNhp4585s0Q8SSUDh/WEesBYi4KLM3PTCEwonMAhEXZfY2MIZQOJFZIOKipLpmhjciOiicyCwQcVEyHzmCS3xVAREXBZOVWlhhES95MIhYCxBxUdA118JKiph9Z+CCT55pETlOWSBiOaoScd6bwidddx+iviMiCLxvEZ3tmnt4O2l5IGIiYrQ8rcUyd0bMZVZEhk0iRCxHIyKOzZtNvXbNioi3k1YARJwR0d8YGmZExCc9VMFqijhvsuLGiK30p83NY3bWzO8uMIhYkmbGiKFxrPgYkSEQsRyNiRiGw9c975uHiLUAEWdEtNMU7601l/9YOkJAxHLUO0aMJyt60OedCuNj6WphJUV00bM/prrm3kUzEHwsXS2ssIiXBB9LVwsQcVHwsXS1UO8nDVfOsk9XiI+l44XgoFi+4QSHoLgxdgXgELQCEbGOSB3aQUuNO7GOyAnaQW/Om4mPt80qzKSrv5n7GVqh3ciuzmAdkRO0g84X8faPzWLMT/QHzekPS9QtnflA7ew6IdYROUE7qEfET3UX23/v2oEzTH98rGkeb6cXaLCOyAnaQT0i/vbtg3Dy0d+uHUzdeZP9EeuInKAddO5kRf+5i51weH147SA76Ju6YxvLN5ygHdTTIu72W2G/NS3i9DsHZkWcfIQxIlVoB/WJOHzzu4e7w7hrnnwbzhkBTovYxxvsCUM7qE/EycNfv3k8jCcreu48mBkBZkQcYIxIG9pBfWNE1bq17N8J2GzZ5Zs5bxiYfvMUvylzSL1+KoRD0Kkymr8P8Lr7GwHRgnY//vSHmEhE+3EQ9i/3sYND/VQCh6DlrjW7yyoQkTaCg0Ytol5DRItIHcFBM1dWMEYkjuCgmVmz/ngIzJoJIzjo9Dqi6qKxjkgWwUHnXOL7J0SkiuCguNbMCcFBISInBAeFiJwQHBQickJwUL+I5/vtdsdtnz1qt7emHiOE4PrJIjioV8Tz/S3lXyfePt/vZB6jhOD6ySI4qFfE0QdPw/D01gu9ffZoLwxPtjKPUUJw/WQRHNQrovFtdP9Ib0ctYvqx8CUdbi67AE1BKGhjIp4Y6XQTqDlst/emH6OD4IYii+CghUQ048LDLYi4bAQHLdQ1nzoBM10zIQTXTxbBQf2TFe2bm5hEIqYfo4Tg+skiOGih5RvbNd96geWbJSM4aP6C9mHHLmjrhhAL2stFcFBc4uOE4KAQkROCg0JETggOChE5ITgoROSE4KAQkROCg0JETggOChE5ITgoROSE4KAQkROCg0JETggOChE5ITgoROSE4KAiRKz8DRRUgYi0gYj8gYicgIi0gYj8gYicgIi0gYj8gYicgIi0gYj8gYicgIi0gYj8gYicgIikuSm4frIIDipAxNQfB5aO4JwQkROCcwoQEV2zBCSIiMmKACAiJyAibSAifyAiJyAibSAifyAiJyAibSAifyAiJyAibSAifyAiJyAibSAifyAiJyAibSAifyAiJyAibSAifyAiJyAibSAifySIiDu0BSBARLxnRQIQkROCcwoQEV2zBCSIiMmKACAiJyAibSAifyAiJyAibSAifyAiJwQHhYicEBwUInJCcNDLi/gSrDIVOmhAi8gJwUEliLgyl/gkBxUg4src9CA6KETkg+igAkQU3WNlkBxUgoiSx/BZBAeFiJwQHBQickJwUIjICIwRibMiImLWTB2IyB+IyAjBHkJEVggOChE5ITgoROSE4KAQkREYIxJnRUTErJk6EJE/EJERgj2EiKwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICcFBISInBAeFiJwQHBQickJwUIjICPx5C+KsiIgr+gd/zvfb7Y7dPG0b9sLRPfXt1otmilYciMgfr4jn+1vh2aNO8sChEvB0q4EiLc6KiLiaXfPog6eqKUxav9O3jpSMe82UakFWRUTJQb0iGgdH94/cj+f7HfXlyYdJz/wSrDKNiXhiRNTNovVSN4imqx49wBhxWQgOWlBE0yBazh6R658F108WwUELds1J06ichIjLQnBQ/2RFOxhPVuyG7Z8fP/U9Z1kIrp8sgoMWXL453LKP7WVm0lQQXD9ZBAfNX9A+jL/o8SHF9WzJ9ZNFcFBc4uOE4KAQkROCg0JETggOChE5ITgoROSE4KAQkROCg4oQEfAHIgISQERAAogISAARAQkgIiABRAQk4Cyivj/Ivs01PFTfaL7DsBxnj/QtoCqpfadG294QpTfeOsp5KjN4i9hxW/p2SX0DpTjOHn+o74cf/fL+UTi6t6cddLeJnggzUYSI9qbxU2FVozl7/Ef963Xy+/tHLu3pz55SvVG+FCJEFNkYGs4e/+V3R+H5H/5x/yj1tiHN1I/s4S2iGSJ2yN45Xh7V7h3uhaNfje4fZRt8cb97vEXsJD8oF4VVjUaJeNIJTzrTIorzUI6I8jorjRJx9OC/T56O4q75/D/qy+heZ7nlqh4RItrGguA7/0ujRDx/8qcHL0bxZEXPndWEZcnlqh4RIp7v6wGitAUNjZ4bn6hR8Mgs33Ts8o3Epl+GiHZBW+JsRYuovTMfdxAtaJ/E6/iC4CwiEAREBCSAiIAEEBGQACICEkBEQAKICEgAEXOZdIOW2RgEV4+n/m+wthtvj7d3GiyVNCBiLkpEK2APItYHRMxl0v3Bba3b+O13IWJtQMRcJt2Nnu6bB1c/1iIOgsB21f0gWPtUi9i3j0DEMkDEXJSIA21gr9VT3wbBjlJuQ/24fqB+UCL21b/hZgsilgIi5qJEHF47CMe3d5WIk65pHNd2h5tau97a7njbPLJ+ABHLABFzUSJOujuqZz5WIlr/1FdlXmiMtMNE9QhELANEzEWJGPY3VM8cxiIq5/qxiIEFIpYCIuaiRRxe++rhbnhBixhislIOiJiLFnHSfU8NE2fHiH09RnT+QcQyQMRctIhhL9Bf0rNmPVmOZ8121gIRLw9EzMWIqP0zInrWEVVHDRHLABEBCSAiIAFEBCSAiIAEEBGQACICEkBEQAKICEjwf8Krh81ZYzyQAAAAAElFTkSuQmCC" alt="plot of chunk accuracy-plot" /></p>
<h3 id="sec:empirical-nu-analysis">Empirical \(\nu\) Analysis</h3>
<ol start="13">
<li>FS sequential selection based on \(\hat{\nu}_{n,j,S}\) values:</li>
</ol>
<pre><code class="language-r">run_sequential_lag_selection &lt;- function(Temp12_Train, d = 364) {
  # Initialization
  A &lt;-  sort(unique(Temp12_Train))
  lenA &lt;- length(A)
  lenX &lt;- length(Temp12_Train)
  A_pairs &lt;- matrix(A, ncol = 2) # All unique state pairs
  ct &lt;- countsTab(X = Temp12_Train, d = 364) # Sequence counts table

  # Initialize storage
  results &lt;- list(
    nuj1 = numeric(d),
    nuj2 = numeric(d-1),
    nuj3 = numeric(d-2),
    selected_lags = numeric(3)
  )

  # Helper function for empirical distribution calculation
  PI &lt;- function(S, groupTab, x_S, lenX, d) {
    if (length(S) &gt; 0) {
      filtr_S &lt;- paste0(&quot;x&quot;, S)
      groupTab &lt;- groupTab %&gt;%
        dplyr::mutate(match = purrr::pmap_lgl(dplyr::pick(dplyr::all_of(filtr_S)),
                                              ~ all(c(...) == x_S))) %&gt;%
        dplyr::filter(match) %&gt;%
        dplyr::select(-match)
    }
    PI &lt;- matrix(groupTab$Nx_Sj/(lenX - d),ncol = 1)
    PI
  }

  # Sequential Selection Process
  cat(&quot;=== Starting Sequential Lag Selection ===\n&quot;)

  # Step 1: Initial selection (S = ∅)
  cat(&quot;\n[Step 1] Selecting first lag (S = ∅)...\n&quot;)
  S &lt;- NULL
  Sc &lt;- sort(setdiff(seq_len(d), S), decreasing = TRUE) # Complement of S in 1:d

  for (z in seq_along(Sc)) { # Runs across all available lags
    j &lt;- Sc[z]
    # Frequency tables
    b_Sja &lt;- freqTab(S = S, j = j, A = A, countsTab = ct)
    b_Sj &lt;- b_Sja %&gt;%
      dplyr::group_by(dplyr::across(dplyr::all_of(paste0(&quot;x&quot;, j)))) %&gt;%
      dplyr::summarise(Nx_Sj = sum(Nxa_Sj), .groups = &quot;drop&quot;)

    # Compute νj
    PIs &lt;- PI(S = S, groupTab = b_Sj, x_S = S, lenX = lenX, d = 364)
    dTVs &lt;- dTV_sample(S = S, j = j, lenA = lenA, base = b_Sja,
                       A_pairs = A_pairs, x_S = S)
    results$nuj1[z] &lt;- prod(PIs) * dTVs
  }
  results$selected_lags[1] &lt;- Sc[which.max(results$nuj1)]
  cat(sprintf(&quot;Selected: j = %d (ν = %.4f)\n&quot;,
              results$selected_lags[1], max(results$nuj1)))

  # Step 2: Second selection (S = {1})
  cat(sprintf(&quot;\n[Step 2] Selecting second lag (S = {%d})...\n&quot;,
              results$selected_lags[1]))
  S &lt;- results$selected_lags[1]
  Sc &lt;- sort(setdiff(seq_len(d), S), decreasing = TRUE)

  for (z in seq_along(Sc)) {
    j &lt;- Sc[z]
    Sj &lt;- sort(c(S, j), decreasing = TRUE)

    # Frequency tables
    b_Sja &lt;- freqTab(S = S, j = j, A = A, countsTab = ct)
    b_Sj &lt;- b_Sja %&gt;%
      dplyr::group_by(dplyr::across(dplyr::all_of(paste0(&quot;x&quot;, Sj)))) %&gt;%
      dplyr::summarise(Nx_Sj = sum(Nxa_Sj), .groups = &quot;drop&quot;)
    b_S &lt;- b_Sja %&gt;%
      dplyr::group_by(dplyr::across(dplyr::all_of(paste0(&quot;x&quot;, S)))) %&gt;%
      dplyr::summarise(Nx_Sj = sum(Nxa_Sj), .groups = &quot;drop&quot;)

    subx &lt;- b_S[, -ncol(b_S)]

    # Compute ν_j
    for (t in which(b_S$Nx_Sj &gt; 0)) {
      PIs &lt;- PI(S = S, groupTab = b_Sj, x_S = subx[t, ],
                lenX = lenX, d = d)
      dTVs &lt;- dTV_sample(S = S, j = j, lenA = lenA, base = b_Sja,
                         A_pairs = A_pairs, x_S = subx[t, ])
      PI_xS &lt;- as.numeric(b_S[t, ncol(b_S)]/(lenX - d))
      results$nuj2[z] &lt;- results$nuj2[z] + prod(PIs) * dTVs/PI_xS
    }
  }
  results$selected_lags[2] &lt;- Sc[which.max(results$nuj2)]
  cat(sprintf(&quot;Selected: j = %d (ν = %.4f)\n&quot;,
              results$selected_lags[2], max(results$nuj2)))

  # Step 3: Third selection (S = {1,364})
  cat(sprintf(&quot;\n[Step 3] Selecting third lag (S = {%d,%d})...\n&quot;,
              results$selected_lags[1], results$selected_lags[2]))
  S &lt;- c(S, results$selected_lags[2])
  Sc &lt;- sort(setdiff(seq_len(d), S), decreasing = TRUE)

  for (z in seq_along(Sc)) {
    j &lt;- Sc[z]
    Sj &lt;- sort(c(S, j), decreasing = TRUE)
    dec_S &lt;- rev(S) # S in decreasing order

    # Frequency tables
    b_Sja &lt;- freqTab(S = dec_S, j = j, A = A, countsTab = ct)
    b_Sj &lt;- b_Sja %&gt;%
      dplyr::group_by(dplyr::across(dplyr::all_of(paste0(&quot;x&quot;, Sj)))) %&gt;%
      dplyr::summarise(Nx_Sj = sum(Nxa_Sj), .groups = &quot;drop&quot;)
    b_S &lt;- b_Sja %&gt;%
      dplyr::group_by(dplyr::across(dplyr::all_of(paste0(&quot;x&quot;, dec_S)))) %&gt;%
      dplyr::summarise(Nx_Sj = sum(Nxa_Sj), .groups = &quot;drop&quot;)

    subx &lt;- b_S[, -ncol(b_S)]

    # Compute ν_j
    for (t in which(b_S$Nx_Sj &gt; 0)) {
      PIs &lt;- PI(S = dec_S, groupTab = b_Sj, x_S = subx[t, ],
                lenX = lenX, d = d)
      dTVs &lt;- dTV_sample(S = dec_S, j = j, lenA = lenA, base = b_Sja,
                         A_pairs = A_pairs, x_S = subx[t, ])
      PI_xS &lt;- as.numeric(b_S[t, ncol(b_S)]/(lenX - d))
      results$nuj3[z] &lt;- results$nuj3[z] + prod(PIs) * dTVs/PI_xS
    }
  }
  results$selected_lags[3] &lt;- Sc[which.max(results$nuj3)]
  cat(sprintf(&quot;Selected: j = %d (ν = %.4f)\n&quot;,
              results$selected_lags[3], max(results$nuj3)))

  # Final Results
  cat(&quot;\n=== Final Selection Results ===\n&quot;)
  print(data.frame(Step = 1:3, Selected_Lag = results$selected_lags,
                   nu = c(max(results$nuj1), max(results$nuj2), max(results$nuj3))))

  return(results)
}
</code></pre>
<pre><code class="language-r">recompute &lt;-  TRUE
recompute &lt;- ifelse(recompute_all, TRUE, recompute)
if (recompute) {
  results &lt;- run_sequential_lag_selection(Temp12_Train) #takes ~6 min
} else {
  results &lt;- readRDS(&quot;results_sequential_selection.rds&quot;) # using precomputed results
  cat(&quot;\n=== Final Selection Results ===\n&quot;)
  print(data.frame(Step = 1:3, Selected_Lag = results$selected_lags,
                   nu = c(max(results$nuj1), max(results$nuj2), max(results$nuj3))))
}
</code></pre>
<pre><code>## === Starting Sequential Lag Selection ===
## 
## [Step 1] Selecting first lag (S = ∅)...
## Selected: j = 1 (ν = 0.1253)
## 
## [Step 2] Selecting second lag (S = {1})...
## Selected: j = 364 (ν = 0.0216)
## 
## [Step 3] Selecting third lag (S = {1,364})...
## Selected: j = 6 (ν = 0.0165)
## 
## === Final Selection Results ===
##   Step Selected_Lag         nu
## 1    1            1 0.12533879
## 2    2          364 0.02162680
## 3    3            6 0.01652459
</code></pre>
<h3 id="sec:plot-figure-4-fs-sequential-step-analysis-through-hat-nu-n-j-s">Plot Figure 4: FS sequential step analysis through \(\hat{\nu}_{n,j,S}\).</h3>
<pre><code class="language-r">par(mfrow = c(1, 3), mar = c(5, 6, 4, 2), oma = c(0, 0, 4, 0))
palette &lt;- c(&quot;#E41A1C&quot;, &quot;#377EB8&quot;, &quot;#4DAF4A&quot;)
with(results, {
  # Graph 1
  Sc &lt;-  364:1
  plot(1:364, rev(nuj1), type = &quot;p&quot;, pch = 19, cex = 0.8, col = &quot;gray70&quot;,
       ylab = &quot;&quot;, xlab = &quot;Lag (-j)&quot;, cex.lab = 1.8, cex.axis = 1.3,
       ylim = c(0,0.13), main = &quot;&quot;, panel.first = grid())
  title(main = expression(paste(&quot;S = &quot;, Ø)), cex.main = 1.5, font.main = 1)
  title(ylab = expression(widehat(nu)[n*&quot;,&quot;*j*&quot;,&quot;*S]), line = 4, cex.lab = 1.8)
  points(Sc[which.max(nuj1)], nuj1[which.max(nuj1)], pch = 21, bg = palette[1], cex = 1.5, lwd = 1)
  text(Sc[which.max(nuj1)], nuj1[which.max(nuj1)], labels = paste0(Sc[which.max(nuj1)]),
       pos = 3, col = palette[1], font = 2, cex = 1.4)
  # Graph 2
  Sc &lt;- 364:2
  plot(2:364, rev(nuj2), type = &quot;p&quot;, pch = 19, cex = 0.8, col = &quot;gray70&quot;,
       ylab = &quot;&quot;, xlab = &quot;Lag (-j)&quot;, cex.lab = 1.8, cex.axis = 1.3,
       ylim = c(0,0.025),  main = &quot;&quot;, panel.first = grid())
  title(main = &quot;With S = {-1}&quot;, cex.main = 1.5, font.main = 1)
  title(ylab = expression(widehat(nu)[n*&quot;,&quot;*j*&quot;,&quot;*S]), line = 4, cex.lab = 1.8)
  points(Sc[which.max(nuj2)], nuj2[which.max(nuj2)], pch = 21, bg = palette[2], cex = 1.5, lwd = 1)
  text(Sc[which.max(nuj2)]-5, nuj2[which.max(nuj2)], labels = paste0(Sc[which.max(nuj2)]),
       pos = 3, col = palette[2], font = 2, cex = 1.4)
  # Graph 3
  Sc &lt;- 363:2
  plot(2:363, rev(nuj3), type = &quot;p&quot;, pch = 19, cex = 0.8, col = &quot;gray70&quot;,
       ylab = &quot;&quot;, xlab = &quot;Lag (-j)&quot;, cex.lab = 1.8, cex.axis = 1.3,
       ylim = c(0,0.025), main = &quot;&quot;, panel.first = grid())
  title(main = &quot;With S = {-364, -1}&quot;, cex.main = 1.5, font.main = 1)
  title(ylab = expression(widehat(nu)[n*&quot;,&quot;*j*&quot;,&quot;*S]), line = 4, cex.lab = 1.8)
  points(Sc[which.max(nuj3)], nuj3[which.max(nuj3)], pch = 21, bg = palette[3], cex = 1.5, lwd = 1)
  text(Sc[which.max(nuj3)], nuj3[which.max(nuj3)], labels = paste0(Sc[which.max(nuj3)]),
       pos = 3, col = palette[3], font = 2, cex = 1.4)

  mtext(expression(paste(&quot;Sequential lag selection based on &quot;, widehat(nu)[n*&quot;,&quot;*j*&quot;,&quot;*S])),
        outer = TRUE, cex = 1.6, font = 2, line = 1.4)
})
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk nu-plot" /></p>
<h2 id="sec:session-info">Session info</h2>
<pre><code class="language-r">sessionInfo()
</code></pre>
<pre><code>## R version 4.4.1 (2024-06-14 ucrt)
## Platform: x86_64-w64-mingw32/x64
## Running under: Windows 11 x64 (build 26100)
## 
## Matrix products: default
## 
## 
## locale:
## [1] LC_COLLATE=Portuguese_Brazil.utf8  LC_CTYPE=Portuguese_Brazil.utf8    LC_MONETARY=Portuguese_Brazil.utf8
## [4] LC_NUMERIC=C                       LC_TIME=Portuguese_Brazil.utf8    
## 
## time zone: America/Sao_Paulo
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] future.apply_1.20.0 future_1.67.0       tidyr_1.3.1         purrr_1.1.0         lubridate_1.9.4     ggplot2_3.5.2      
##  [7] dplyr_1.1.4         hdMTD_0.1.2         testthat_3.2.1.1    devtools_2.4.5      usethis_2.2.3      
## 
## loaded via a namespace (and not attached):
##  [1] tidyselect_1.2.1   farver_2.1.2       fastmap_1.2.0      xopen_1.0.1        promises_1.3.0     digest_0.6.36     
##  [7] timechange_0.3.0   mime_0.12          lifecycle_1.0.4    waldo_0.5.2        ellipsis_0.3.2     processx_3.8.4    
## [13] magrittr_2.0.3     compiler_4.4.1     rlang_1.1.6        tools_4.4.1        knitr_1.48         labeling_0.4.3    
## [19] prettyunits_1.2.0  htmlwidgets_1.6.4  pkgbuild_1.4.4     curl_5.2.1         RColorBrewer_1.1-3 xml2_1.3.6        
## [25] pkgload_1.4.0      miniUI_0.1.1.1     withr_3.0.2        desc_1.4.3         grid_4.4.1         fansi_1.0.6       
## [31] roxygen2_7.3.2     diffobj_0.3.5      urlchecker_1.0.1   profvis_0.3.8      xtable_1.8-4       colorspace_2.1-1  
## [37] globals_0.18.0     scales_1.3.0       cli_3.6.5          crayon_1.5.3       generics_0.1.4     remotes_2.5.0     
## [43] rstudioapi_0.16.0  commonmark_2.0.0   sessioninfo_1.2.2  cachem_1.1.0       stringr_1.5.1      parallel_4.4.1    
## [49] vctrs_0.6.5        callr_3.7.6        rcmdcheck_1.4.0    listenv_0.9.1      glue_1.8.0         parallelly_1.45.1 
## [55] rematch2_2.1.2     codetools_0.2-20   ps_1.7.7           stringi_1.8.4      gtable_0.3.5       later_1.3.2       
## [61] munsell_0.5.1      tibble_3.3.0       pillar_1.11.0      htmltools_0.5.8.1  brio_1.1.5         R6_2.6.1          
## [67] rprojroot_2.0.4    shiny_1.8.1.1      evaluate_0.24.0    highr_0.11         memoise_2.0.1      httpuv_1.6.15     
## [73] Rcpp_1.0.13-1      xfun_0.52          fs_1.6.4           pkgconfig_2.0.3
</code></pre>
</div>
</body>
</html>
